#!/usr/bin/env python3
"""
Script de configuration automatique pour l'agent alternance + n8n + Mistral AI
==============================================================================

Ce script configure automatiquement :
- Connexion √† n8n avec credentials
- Configuration Mistral AI (au lieu d'OpenAI)
- Import du workflow principal
- Validation de la configuration

Auteur: Assistant IA
Version: 1.0 - Mistral Edition
"""

import os
import json
import requests
import secrets
from pathlib import Path
from dotenv import load_dotenv
import logging

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class N8nMistralConfigurator:
    """Configurateur automatique pour n8n et l'agent alternance avec Mistral."""

    def __init__(self):
        """Initialise le configurateur avec les variables d'environnement."""
        load_dotenv()

        self.login = os.getenv('LOGIN_N8N')
        self.password = os.getenv('PASSWORD_N8N')
        self.host = os.getenv('N8N_HOST', 'localhost')
        self.port = os.getenv('N8N_PORT', '5678')
        self.protocol = os.getenv('N8N_PROTOCOL', 'http')
        self.base_url = f"{self.protocol}://{self.host}:{self.port}"

        # Validation des credentials requis
        if not self.login or not self.password:
            raise ValueError("LOGIN_N8N et PASSWORD_N8N doivent √™tre d√©finis dans .env")

    def generate_encryption_key(self) -> str:
        """G√©n√®re une cl√© d'encryption s√©curis√©e pour n8n."""
        return secrets.token_urlsafe(32)

    def test_connection(self) -> bool:
        """Teste la connexion √† n8n."""
        try:
            logger.info(f"Test connexion √† {self.base_url}")
            response = requests.get(
                f"{self.base_url}/healthz",
                auth=(self.login, self.password),
                timeout=10
            )
            return response.status_code == 200
        except requests.exceptions.RequestException as e:
            logger.error(f"Erreur connexion n8n: {e}")
            return False

    def get_existing_credentials(self) -> dict:
        """R√©cup√®re la liste des credentials existants."""
        try:
            response = requests.get(
                f"{self.base_url}/api/v1/credentials",
                auth=(self.login, self.password)
            )
            if response.status_code == 200:
                existing = {cred['name']: cred['id'] for cred in response.json()}
                logger.info(f"Credentials existants: {list(existing.keys())}")
                return existing
            return {}
        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration credentials: {e}")
            return {}

    def create_credentials(self) -> bool:
        """Cr√©e les credentials n√©cessaires pour Mistral."""
        logger.info("Cr√©ation des credentials API avec Mistral...")

        existing_creds = self.get_existing_credentials()
        success_count = 0

        # Configuration des credentials avec Mistral
        credentials_config = [
            {
                "name": "Mistral AI API Key",
                "type": "httpHeaderAuth",  # Credential g√©n√©rique pour Mistral
                "data": {
                    "name": "Authorization",
                    "value": f"Bearer {os.getenv('MISTRAL_API_KEY', '')}"
                },
                "required_env": "MISTRAL_API_KEY"
            },
            {
                "name": "Mistral Chat Endpoint",
                "type": "httpHeaderAuth",
                "data": {
                    "name": "Content-Type",
                    "value": "application/json"
                },
                "required_env": "MISTRAL_CHAT_ENDPOINT"
            }
        ]

        # Credentials optionnels
        optional_credentials = [
            {
                "name": "SMTP Email",
                "type": "smtp",
                "data": {
                    "user": os.getenv('SMTP_USER', ''),
                    "password": os.getenv('SMTP_PASSWORD', ''),
                    "host": os.getenv('SMTP_HOST', 'smtp.gmail.com'),
                    "port": int(os.getenv('SMTP_PORT', '587')),
                    "secure": os.getenv('SMTP_SECURE', 'false').lower() == 'true'
                },
                "required_env": "SMTP_USER"
            },
            {
                "name": "Slack Webhook",
                "type": "slackApi",
                "data": {
                    "accessToken": os.getenv('SLACK_BOT_TOKEN', ''),
                    "webhookUrl": os.getenv('SLACK_WEBHOOK_URL', '')
                },
                "required_env": "SLACK_WEBHOOK_URL"
            }
        ]

        # Combine les credentials obligatoires et optionnels
        all_credentials = credentials_config + optional_credentials

        for cred_config in all_credentials:
            cred_name = cred_config['name']
            required_env = cred_config['required_env']

            # V√©rifier si la variable d'environnement est d√©finie
            if not os.getenv(required_env):
                logger.warning(f"Variable {required_env} non d√©finie, ignor√© {cred_name}")
                continue

            # V√©rifier si le credential existe d√©j√†
            if cred_name in existing_creds:
                logger.info(f"Credential '{cred_name}' existe d√©j√†")
                success_count += 1
                continue

            # Cr√©er le credential
            try:
                credential_data = {
                    "name": cred_name,
                    "type": cred_config['type'],
                    "data": cred_config['data']
                }

                response = requests.post(
                    f"{self.base_url}/api/v1/credentials",
                    json=credential_data,
                    auth=(self.login, self.password)
                )

                if response.status_code in [200, 201]:
                    logger.info(f"‚úÖ Credential '{cred_name}' cr√©√© avec succ√®s")
                    success_count += 1
                else:
                    logger.error(f"‚ö†Ô∏è Erreur cr√©ation '{cred_name}': {response.status_code} - {response.text}")

            except Exception as e:
                logger.error(f"‚ùå Exception cr√©ation '{cred_name}': {e}")

        logger.info(f"Credentials cr√©√©s: {success_count}")
        return success_count > 0

    def validate_environment(self) -> dict:
        """Valide les variables d'environnement pour Mistral."""
        validation_results = {
            'required': {},
            'optional': {},
            'missing_required': [],
            'missing_optional': []
        }

        # Variables requises pour n8n
        required_vars = {
            'LOGIN_N8N': 'Login n8n',
            'PASSWORD_N8N': 'Password n8n'
        }

        # Variables Mistral disponibles
        mistral_vars = {
            'MISTRAL_API_KEY': 'Mistral API Key principal',
            'MISTRAL_API_LOGIN': 'Mistral Login',
            'MISTRAL_API_KEY_CODESTRAL': 'Mistral Codestral Key',
            'MISTRAL_CHAT_ENDPOINT': 'Mistral Chat Endpoint',
            'MISTRAL_COMPLETION_ENDPOINT': 'Mistral Completion Endpoint',
            'MISTRAL_API_KEY_CURSOR_MCP_SERVER': 'Mistral Cursor MCP Key'
        }

        # Variables optionnelles
        optional_vars = {
            'N8N_ENCRYPTION_KEY': 'Cl√© encryption n8n',
            'SMTP_USER': 'Notifications email',
            'SMTP_PASSWORD': 'Password email',
            'SLACK_WEBHOOK_URL': 'Notifications Slack (optionnel)',
            'SLACK_BOT_TOKEN': 'Slack Bot Token (optionnel)'
        }

        # V√©rification variables requises
        for var, desc in required_vars.items():
            value = os.getenv(var)
            if value:
                validation_results['required'][var] = f"‚úÖ {desc}"
            else:
                validation_results['missing_required'].append(f"‚ùå {var}: {desc}")

        # V√©rification variables Mistral
        for var, desc in mistral_vars.items():
            value = os.getenv(var)
            if value:
                validation_results['required'][var] = f"‚úÖ {desc}"

        # V√©rification variables optionnelles
        for var, desc in optional_vars.items():
            value = os.getenv(var)
            if value:
                validation_results['optional'][var] = f"‚úÖ {desc}"
            else:
                validation_results['missing_optional'].append(f"‚ö†Ô∏è {var}: {desc}")

        return validation_results

    def print_configuration_summary(self):
        """Affiche un r√©sum√© de la configuration."""
        logger.info("üìã R√âSUM√â DE LA CONFIGURATION - MISTRAL EDITION")
        logger.info("=" * 55)
        logger.info(f"n8n URL: {self.base_url}")
        logger.info(f"Login: {self.login}")
        logger.info(f"Interface: {self.base_url}")

        # Validation environnement
        validation = self.validate_environment()

        logger.info("\nü§ñ CONFIGURATION MISTRAL AI:")
        mistral_count = 0
        for var, status in validation['required'].items():
            if 'MISTRAL' in var:
                logger.info(f"  {status}")
                mistral_count += 1

        logger.info(f"\nüîß VARIABLES N8N:")
        for var, status in validation['required'].items():
            if 'N8N' in var or var in ['LOGIN_N8N', 'PASSWORD_N8N']:
                logger.info(f"  {status}")

        logger.info(f"\nüìß NOTIFICATIONS (OPTIONNELLES):")
        for var, status in validation['optional'].items():
            logger.info(f"  {status}")

        if validation['missing_required']:
            logger.warning("\n‚ùå VARIABLES REQUISES MANQUANTES:")
            for missing in validation['missing_required']:
                logger.warning(f"  {missing}")

        if validation['missing_optional']:
            logger.info("\n‚ö†Ô∏è VARIABLES OPTIONNELLES MANQUANTES:")
            for missing in validation['missing_optional']:
                logger.info(f"  {missing}")

        logger.info(f"\nüéØ Configuration Mistral: {mistral_count} variables trouv√©es")

def generate_missing_variables():
    """G√©n√®re les variables manquantes."""
    print("\nüîß G√âN√âRATION DES VARIABLES MANQUANTES")
    print("=" * 50)

    # G√©n√©rer cl√© encryption n8n
    if not os.getenv('N8N_ENCRYPTION_KEY'):
        encryption_key = secrets.token_urlsafe(32)
        print(f"N8N_ENCRYPTION_KEY={encryption_key}")
        print("üëÜ Ajouter cette ligne dans votre fichier .env")

    # Instructions SMTP
    if not os.getenv('SMTP_USER'):
        print("\nüìß CONFIGURATION EMAIL (Optionnelle)")
        print("Pour recevoir des notifications par email :")
        print("SMTP_USER=votre_email@gmail.com")
        print("SMTP_PASSWORD=votre_mot_de_passe_app_gmail")
        print("üí° Mot de passe d'app Gmail : Google > Compte > S√©curit√© > Mots de passe des applications")

    # Instructions Slack
    if not os.getenv('SLACK_WEBHOOK_URL'):
        print("\nüí¨ CONFIGURATION SLACK (Optionnelle)")
        print("Pour recevoir des notifications Slack :")
        print("1. Cr√©er une app Slack : https://api.slack.com/apps")
        print("2. Activer Incoming Webhooks")
        print("3. Copier l'URL du webhook")
        print("SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...")

def main():
    """Point d'entr√©e principal."""
    print("ü§ñ Configuration automatique Agent Alternance + n8n + Mistral AI")
    print("=" * 70)

    try:
        # G√©n√©ration des variables manquantes
        generate_missing_variables()

        # Initialisation
        configurator = N8nMistralConfigurator()
        configurator.print_configuration_summary()

        # Test connexion
        print("\nüîç Test connexion n8n...")
        if not configurator.test_connection():
            print("‚ùå Connexion n8n √©chou√©e")
            print("V√©rifications n√©cessaires :")
            print("  1. n8n est-il d√©marr√© ?")
            print("  2. Les credentials LOGIN_N8N/PASSWORD_N8N sont-ils corrects ?")
            print("  3. Le port 5678 est-il accessible ?")

            # Suggestion pour d√©marrer n8n
            print("\nüöÄ Pour d√©marrer n8n :")
            print("  npm install -g n8n")
            print("  n8n start")
            print("  OU docker-compose up -d n8n")
            return False

        print("‚úÖ Connexion n8n r√©ussie")

        # Cr√©ation credentials
        print("\nüîê Configuration des credentials Mistral...")
        creds_success = configurator.create_credentials()

        # R√©sultats finaux
        print("\n" + "=" * 70)
        if creds_success:
            print("üéâ Configuration Mistral termin√©e avec succ√®s !")
            print(f"üåê Interface n8n: {configurator.base_url}")
            print(f"üë§ Login: {configurator.login}")
            print("\nüìù Prochaines √©tapes :")
            print("  1. D√©marrer n8n si pas encore fait")
            print("  2. Importer le workflow alternance")
            print("  3. Tester l'agent avec Mistral")
            print("  4. Lancer: python agent_alternance_starter.py")
        else:
            print("‚ö†Ô∏è Configuration partiellement r√©ussie")
            print("V√©rifiez les logs ci-dessus pour les d√©tails")

        return True

    except ValueError as e:
        logger.error(f"Erreur configuration: {e}")
        print("\n‚ùå Configuration √©chou√©e")
        print("V√©rifiez que LOGIN_N8N et PASSWORD_N8N sont d√©finis dans .env")
        return False
    except Exception as e:
        logger.error(f"Erreur inattendue: {e}")
        print(f"\n‚ùå Erreur inattendue: {e}")
        return False

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)