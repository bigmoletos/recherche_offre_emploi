{
  "name": "TEST - Alternative Gratuite (HuggingFace)",
  "nodes": [
    {
      "parameters": {},
      "id": "start-alternative",
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "// TEST AVEC ALTERNATIVE GRATUITE\nconsole.log('üÜì === TEST ALTERNATIVE GRATUITE ===');\n\nconst offreTest = {\n  title: 'Contrat d\\'apprentissage - Analyste Cybers√©curit√© SOC',\n  company: 'Orange Cyberdefense',\n  description: 'Formation en alternance 24 mois pour analyste cybers√©curit√© SOC. Surveillance syst√®mes, incidents s√©curit√©, SIEM.',\n  contract_type: 'Contrat d\\'apprentissage',\n  attendu: 'VALIDE'\n};\n\n// TENTATIVE 1 : PROMPT SIMPLE POUR LLAMA\nconst promptSimple = `Analyse cette offre d'emploi :\nTitre: ${offreTest.title}\nType: ${offreTest.contract_type}\nDescription: ${offreTest.description}\n\nEst-ce une offre d'alternance en cybers√©curit√© ? R√©ponds par VALIDE ou INVALIDE.`;\n\n// TENTATIVE 2 : OPENAI COMPATIBLE (si vous avez un compte)\nconst payloadOpenAI = {\n  model: \"gpt-3.5-turbo\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"Tu classifies les offres d'alternance cybers√©curit√©. R√©ponds par VALIDE ou INVALIDE.\"\n    },\n    {\n      role: \"user\", \n      content: promptSimple\n    }\n  ],\n  max_tokens: 50,\n  temperature: 0.1\n};\n\nconsole.log('üìã Offre √† tester:', offreTest.title);\nconsole.log('üéØ R√©sultat attendu:', offreTest.attendu);\n\nreturn [\n  {\n    json: {\n      ...offreTest,\n      test_type: 'HUGGINGFACE_LLAMA',\n      api_url: 'https://api-inference.huggingface.co/models/meta-llama/Llama-2-7b-chat-hf',\n      prompt: promptSimple,\n      headers: {\n        'Content-Type': 'application/json'\n        // Pas de cl√© requise pour test basique\n      }\n    }\n  },\n  {\n    json: {\n      ...offreTest,\n      test_type: 'OPENAI_COMPATIBLE',\n      api_url: 'https://api.openai.com/v1/chat/completions',\n      payload_string: JSON.stringify(payloadOpenAI),\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': 'Bearer REMPLACER_PAR_CLE_OPENAI'\n      },\n      note: 'Remplacer la cl√© OpenAI si disponible'\n    }\n  }\n];"
      },
      "id": "generate-alternatives",
      "name": "üÜì G√©n√©rer Alternatives",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-hf",
              "leftValue": "={{ $json.test_type }}",
              "rightValue": "HUGGINGFACE_LLAMA",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "route-by-type",
      "name": "Type de test ?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.api_url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "raw",
        "body": "={\"inputs\": \"{{ $json.prompt }}\", \"parameters\": {\"max_new_tokens\": 50, \"temperature\": 0.1}}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "test-huggingface",
      "name": "ü§ó Test HuggingFace",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 200],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// SIMULATION LOCALE SI API √âCHOUE\nconst offre = $('üÜì G√©n√©rer Alternatives').item.json;\n\nconsole.log('üíª === SIMULATION LOCALE ===');\nconsole.log('üéØ Offre:', offre.title);\n\n// LOGIQUE DE CLASSIFICATION BASIQUE\nlet classification = 'INCERTAIN';\nlet confidence = 0.5;\nlet justification = 'Classification automatique locale';\n\n// Mots-cl√©s positifs\nconst motsAlternance = ['apprentissage', 'alternance', 'contrat pro', 'formation'];\nconst motsCyber = ['cybers√©curit√©', 'cyber', 's√©curit√© informatique', 'SOC', 'SIEM', 'pentest'];\n\n// Mots-cl√©s n√©gatifs  \nconst motsNegatifs = ['stage', 'cdi', 'cdd', 'freelance', 'marketing', 'commercial'];\n\nconst texteComplet = `${offre.title} ${offre.description} ${offre.contract_type}`.toLowerCase();\n\n// V√©rification alternance\nconst hasAlternance = motsAlternance.some(mot => texteComplet.includes(mot.toLowerCase()));\nconst hasCyber = motsCyber.some(mot => texteComplet.includes(mot.toLowerCase()));\nconst hasNegatif = motsNegatifs.some(mot => texteComplet.includes(mot.toLowerCase()));\n\nif (hasAlternance && hasCyber && !hasNegatif) {\n  classification = 'VALIDE';\n  confidence = 0.85;\n  justification = 'Contrat alternance + domaine cybers√©curit√© d√©tect√©s';\n} else if (hasNegatif) {\n  classification = 'INVALIDE';\n  confidence = 0.9;\n  justification = 'Mots-cl√©s exclusifs d√©tect√©s';\n} else if (!hasAlternance) {\n  classification = 'INVALIDE';\n  confidence = 0.8;\n  justification = 'Pas de contrat alternance d√©tect√©';\n} else if (!hasCyber) {\n  classification = 'INVALIDE';\n  confidence = 0.8;\n  justification = 'Domaine cybers√©curit√© non d√©tect√©';\n}\n\nconst isCorrect = classification === offre.attendu;\n\nconsole.log(`üìä Classification: ${classification}`);\nconsole.log(`üéØ Attendu: ${offre.attendu}, Correct: ${isCorrect}`);\nconsole.log(`üí° Justification: ${justification}`);\n\nreturn {\n  json: {\n    ...offre,\n    classification_result: {\n      method: 'CLASSIFICATION_LOCALE',\n      classification: classification,\n      confidence: confidence,\n      justification: justification,\n      is_correct: isCorrect,\n      mots_detectes: {\n        alternance: hasAlternance,\n        cybersecurite: hasCyber,\n        negatifs: hasNegatif\n      }\n    },\n    processed_at: new Date().toISOString(),\n    note: 'Classification locale en attendant API LLM fonctionnelle'\n  }\n};"
      },
      "id": "simulation-locale",
      "name": "üíª Simulation Locale",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "jsCode": "// TRAITEMENT R√âPONSE HUGGINGFACE\nconst originalData = $('üÜì G√©n√©rer Alternatives').item.json;\nconst apiResponse = $input.item.json;\n\nconsole.log('ü§ó === R√âPONSE HUGGINGFACE ===');\nconsole.log('üìä R√©ponse brute:', JSON.stringify(apiResponse, null, 2));\n\nlet classification = 'ERREUR';\nlet confidence = 0;\nlet justification = 'Erreur API';\n\nif (apiResponse && Array.isArray(apiResponse) && apiResponse[0] && apiResponse[0].generated_text) {\n  const reponse = apiResponse[0].generated_text.toLowerCase();\n  console.log('üìù Texte g√©n√©r√©:', reponse);\n  \n  if (reponse.includes('valide') && !reponse.includes('invalide')) {\n    classification = 'VALIDE';\n    confidence = 0.7;\n    justification = 'HuggingFace a class√© comme valide';\n  } else if (reponse.includes('invalide')) {\n    classification = 'INVALIDE';\n    confidence = 0.7;\n    justification = 'HuggingFace a class√© comme invalide';\n  } else {\n    classification = 'INCERTAIN';\n    confidence = 0.3;\n    justification = 'R√©ponse HuggingFace ambigu√´';\n  }\n} else {\n  console.log('‚ùå Structure r√©ponse invalide');\n}\n\nconst isCorrect = classification === originalData.attendu;\n\nreturn {\n  json: {\n    ...originalData,\n    classification_result: {\n      method: 'HUGGINGFACE_API',\n      classification: classification,\n      confidence: confidence,\n      justification: justification,\n      is_correct: isCorrect,\n      raw_response: apiResponse\n    },\n    processed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "process-hf-response",
      "name": "ü§ó Traiter R√©ponse HF",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 200]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "result-summary",
              "name": "summary",
              "value": "üß™ TEST: {{ $json.classification_result.classification }} ({{ $json.classification_result.method }})",
              "type": "string"
            },
            {
              "id": "result-accuracy",
              "name": "accuracy",
              "value": "Attendu: {{ $json.attendu }}, Obtenu: {{ $json.classification_result.classification }}, Correct: {{ $json.classification_result.is_correct }}",
              "type": "string"
            },
            {
              "id": "result-confidence",
              "name": "confidence",
              "value": "={{ $json.classification_result.confidence }}",
              "type": "number"
            },
            {
              "id": "result-justification",
              "name": "justification",
              "value": "{{ $json.classification_result.justification }}",
              "type": "string"
            },
            {
              "id": "result-recommendation",
              "name": "recommendation",
              "value": "{{ $json.classification_result.is_correct ? '‚úÖ M√©thode fiable' : '‚ö†Ô∏è N√©cessite ajustement' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "format-final-result",
      "name": "üìä R√©sultat Final",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1340, 300]
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "üÜì G√©n√©rer Alternatives",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üÜì G√©n√©rer Alternatives": {
      "main": [
        [
          {
            "node": "Type de test ?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Type de test ?": {
      "main": [
        [
          {
            "node": "ü§ó Test HuggingFace",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üíª Simulation Locale",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ó Test HuggingFace": {
      "main": [
        [
          {
            "node": "ü§ó Traiter R√©ponse HF",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "üíª Simulation Locale",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üíª Simulation Locale": {
      "main": [
        [
          {
            "node": "üìä R√©sultat Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ó Traiter R√©ponse HF": {
      "main": [
        [
          {
            "node": "üìä R√©sultat Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true
  },
  "versionId": "alternative-v1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "workflow-alternative-gratuite",
  "tags": ["test", "alternative", "gratuit", "huggingface"]
}