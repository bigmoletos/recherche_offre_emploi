{
  "name": "Classification Mistral - Gestion Erreurs Compl√®te",
  "nodes": [
    {
      "parameters": {},
      "id": "start-main",
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [240, 400]
    },
    {
      "parameters": {
        "jsCode": "// G√âN√âRATEUR D'OFFRES TEST (identique au pr√©c√©dent)\nconst offresTest = [\n  {\n    id: 'test-valide-1',\n    title: 'Contrat d\\'apprentissage - Analyste Cybers√©curit√© SOC',\n    company: 'Orange Cyberdefense',\n    description: 'Contrat d\\'apprentissage cybers√©curit√© SOC.',\n    location: 'Paris, France',\n    contract_type: 'Contrat d\\'apprentissage',\n    keywords: ['apprentissage', 'cybers√©curit√©'],\n    attendu: 'VALIDE'\n  },\n  {\n    id: 'test-invalide-donnees-manquantes',\n    title: '', // Titre manquant\n    company: 'Test Company',\n    description: null, // Description nulle\n    location: 'Paris',\n    contract_type: 'Stage',\n    keywords: [],\n    attendu: 'ERREUR_DONNEES'\n  },\n  {\n    id: 'test-donnees-corrompues',\n    // Donn√©es mal structur√©es\n    invalid_field: 'test',\n    attendu: 'ERREUR_STRUCTURE'\n  }\n];\n\nreturn offresTest.map(offre => ({ json: offre }));"
      },
      "id": "generator-test",
      "name": "üß™ G√©n√©rateur Test",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 400]
    },
    {
      "parameters": {
        "jsCode": "// VALIDATION COMPL√àTE DES DONN√âES D'ENTR√âE\nconst offre = $input.item.json;\n\nconsole.log(`üîç === VALIDATION DONN√âES: ${offre.id || 'ID_MANQUANT'} ===`);\n\n// Structure de validation\nconst validationResult = {\n  isValid: true,\n  errors: [],\n  warnings: [],\n  correctedData: { ...offre }\n};\n\n// 1. VALIDATION DES CHAMPS OBLIGATOIRES\nconst requiredFields = ['id', 'title', 'company', 'description', 'contract_type'];\n\nrequiredFields.forEach(field => {\n  if (!offre[field] || offre[field] === '' || offre[field] === null) {\n    validationResult.errors.push(`Champ obligatoire manquant: ${field}`);\n    validationResult.isValid = false;\n    \n    // Correction automatique si possible\n    if (field === 'id' && !offre.id) {\n      validationResult.correctedData.id = `auto-${Date.now()}`;\n      validationResult.warnings.push('ID g√©n√©r√© automatiquement');\n    }\n    if (field === 'title' && !offre.title) {\n      validationResult.correctedData.title = 'Titre non sp√©cifi√©';\n      validationResult.warnings.push('Titre par d√©faut assign√©');\n    }\n    if (field === 'description' && (!offre.description || offre.description === null)) {\n      validationResult.correctedData.description = 'Description non disponible';\n      validationResult.warnings.push('Description par d√©faut assign√©e');\n    }\n  }\n});\n\n// 2. VALIDATION DES TYPES DE DONN√âES\nif (offre.keywords && !Array.isArray(offre.keywords)) {\n  validationResult.warnings.push('Keywords converti en array');\n  validationResult.correctedData.keywords = typeof offre.keywords === 'string' \n    ? offre.keywords.split(',').map(k => k.trim()) \n    : [];\n}\n\nif (!offre.keywords) {\n  validationResult.correctedData.keywords = [];\n  validationResult.warnings.push('Keywords initialis√© comme array vide');\n}\n\n// 3. VALIDATION DE LA LONGUEUR DES CONTENUS\nif (offre.title && offre.title.length > 200) {\n  validationResult.warnings.push('Titre tronqu√© (>200 caract√®res)');\n  validationResult.correctedData.title = offre.title.substring(0, 200) + '...';\n}\n\nif (offre.description && offre.description.length > 5000) {\n  validationResult.warnings.push('Description tronqu√©e (>5000 caract√®res)');\n  validationResult.correctedData.description = offre.description.substring(0, 5000) + '...';\n}\n\n// 4. VALIDATION DES VALEURS M√âTIER\nconst validContractTypes = [\n  'Contrat d\\'apprentissage', 'Contrat de professionnalisation', \n  'Alternance', 'Stage', 'CDI', 'CDD', 'Freelance'\n];\n\nif (offre.contract_type && !validContractTypes.includes(offre.contract_type)) {\n  validationResult.warnings.push(`Type de contrat non standard: ${offre.contract_type}`);\n}\n\n// R√âSULTATS DE VALIDATION\nconsole.log(`‚úÖ Validation compl√®te: ${validationResult.isValid}`);\nconsole.log(`‚ùå Erreurs (${validationResult.errors.length}):`, validationResult.errors);\nconsole.log(`‚ö†Ô∏è  Warnings (${validationResult.warnings.length}):`, validationResult.warnings);\n\nreturn {\n  json: {\n    ...validationResult.correctedData,\n    validation: validationResult,\n    original_data: offre,\n    validation_timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "validation-node",
      "name": "‚úÖ Validation Donn√©es",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": false,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "condition-valid-data",
              "leftValue": "={{ $json.validation.isValid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "condition-valid",
      "name": "Donn√©es Valides ?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "jsCode": "// GESTION DES ERREURS DE VALIDATION\nconst data = $input.item.json;\n\nconsole.log(`‚ùå === GESTION ERREUR VALIDATION ===`);\nconsole.log('Erreurs:', data.validation.errors);\nconsole.log('Donn√©es originales:', data.original_data);\n\n// Log d√©taill√© pour d√©bogage\nconst errorReport = {\n  error_type: 'VALIDATION_FAILED',\n  error_timestamp: new Date().toISOString(),\n  input_data: data.original_data,\n  validation_errors: data.validation.errors,\n  validation_warnings: data.validation.warnings,\n  corrected_data: {\n    id: data.id,\n    title: data.title,\n    company: data.company,\n    description: data.description,\n    contract_type: data.contract_type\n  },\n  recovery_action: 'DATA_CORRECTION_ATTEMPTED'\n};\n\nconsole.log('üìã Rapport d\\'erreur complet:', JSON.stringify(errorReport, null, 2));\n\nreturn {\n  json: {\n    ...data,\n    error_report: errorReport,\n    status: 'ERREUR_VALIDATION',\n    can_retry: data.validation.warnings.length > 0 && data.validation.errors.length === 0\n  }\n};"
      },
      "id": "error-handler",
      "name": "‚ùå Gestion Erreurs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 600]
    },
    {
      "parameters": {
        "jsCode": "// PR√âPARATION S√âCURIS√âE DU PROMPT MISTRAL\nconst offre = $input.item.json;\n\nconsole.log(`ü§ñ === PR√âPARATION PROMPT S√âCURIS√âE: ${offre.title} ===`);\n\n// V√©rification finale avant appel API\nif (!offre.title || !offre.description || !offre.contract_type) {\n  throw new Error('Donn√©es insuffisantes pour pr√©parer le prompt Mistral');\n}\n\n// Nettoyage et s√©curisation des donn√©es\nconst cleanData = {\n  title: offre.title.replace(/[\"\\n\\r]/g, ' ').trim(),\n  company: (offre.company || 'Entreprise non sp√©cifi√©e').replace(/[\"\\n\\r]/g, ' ').trim(),\n  description: offre.description.replace(/[\"\\n\\r]/g, ' ').trim(),\n  contract_type: offre.contract_type.trim(),\n  keywords: Array.isArray(offre.keywords) ? offre.keywords.join(', ') : ''\n};\n\nconst prompt = `Tu es un expert RH sp√©cialis√© en cybers√©curit√© et contrats d'alternance.\n\nüéØ **MISSION**: Analyser si cette offre correspond EXACTEMENT √† une ALTERNANCE en CYBERS√âCURIT√â.\n\nüìã **OFFRE √Ä ANALYSER**:\n‚Ä¢ **Titre**: ${cleanData.title}\n‚Ä¢ **Entreprise**: ${cleanData.company}\n‚Ä¢ **Description**: ${cleanData.description}\n‚Ä¢ **Type de contrat**: ${cleanData.contract_type}\n‚Ä¢ **Mots-cl√©s**: ${cleanData.keywords}\n\nüîç **CRIT√àRES OBLIGATOIRES**:\n\n**1. TYPE DE CONTRAT (CRITIQUE)**:\n‚úÖ ALTERNANCE: \"alternance\", \"apprentissage\", \"contrat pro\", \"contrat de professionnalisation\"\n‚ùå AUTRES: \"stage\", \"CDI\", \"CDD\", \"freelance\", \"mission\"\n\n**2. DOMAINE CYBERS√âCURIT√â (CRITIQUE)**:\n‚úÖ CYBER: \"cybers√©curit√©\", \"s√©curit√© informatique\", \"s√©curit√© des SI\"\n‚úÖ SP√âCIALIT√âS: \"SOC\", \"SIEM\", \"pentest\", \"audit s√©curit√©\", \"GRC\", \"forensic\"\n‚ùå AUTRES: \"s√©curit√© physique\", \"s√©curit√© b√¢timent\", \"surveillance\", \"marketing\"\n\nüìù **FORMAT DE R√âPONSE OBLIGATOIRE**:\n**CLASSIFICATION**: VALIDE ou INVALIDE\n**JUSTIFICATION**: [Explique en 1-2 phrases pourquoi]\n\nAnalyse maintenant cette offre.`;\n\n// Validation de la taille du prompt\nif (prompt.length > 10000) {\n  console.log('‚ö†Ô∏è Prompt tr√®s long, troncature appliqu√©e');\n  prompt = prompt.substring(0, 9500) + '\\n\\n[...tronc√©...]\\n\\nAnalyse maintenant cette offre.';\n}\n\nconst payload = {\n  model: \"mistral-large-latest\",\n  messages: [\n    {\n      role: \"system\",\n      content: \"Tu es un expert RH avec 15 ans d'exp√©rience en cybers√©curit√© et alternance. Tu analyses les offres avec pr√©cision et rigueur.\"\n    },\n    {\n      role: \"user\",\n      content: prompt\n    }\n  ],\n  temperature: 0.05,\n  max_tokens: 300\n};\n\n// Validation finale du payload\nif (!payload.messages || payload.messages.length === 0) {\n  throw new Error('Payload Mistral invalide: messages vides');\n}\n\nif (!payload.model) {\n  throw new Error('Payload Mistral invalide: mod√®le non sp√©cifi√©');\n}\n\nconsole.log('‚úÖ Payload Mistral pr√©par√© et valid√©');\nconsole.log('üìè Taille prompt:', prompt.length, 'caract√®res');\nconsole.log('üìã Nombre de messages:', payload.messages.length);\n\nreturn {\n  json: {\n    ...offre,\n    mistral_payload: payload,\n    prompt_info: {\n      size: prompt.length,\n      cleaned_data: cleanData,\n      preparation_timestamp: new Date().toISOString()\n    }\n  }\n};"
      },
      "id": "prompt-prep",
      "name": "üìù Pr√©paration Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.mistral.ai/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer fe8GdBIIBwYk8Dj1GvclASPE3j0Zbt95"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "jsonBody": "{\n  \"model\": \"{{ $json.mistral_payload.model }}\",\n  \"messages\": {{ JSON.stringify($json.mistral_payload.messages) }},\n  \"temperature\": {{ $json.mistral_payload.temperature }},\n  \"max_tokens\": {{ $json.mistral_payload.max_tokens }}\n}",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3,
            "retryInterval": 1000
          }
        }
      },
      "id": "mistral-api-call",
      "name": "üåê Appel Mistral API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1340, 300],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// GESTION DES ERREURS API MISTRAL\nconst inputData = $input.first().json;\nconst error = $input.last().error;\n\nconsole.log(`‚ùå === ERREUR API MISTRAL ===`);\nconsole.log('Type d\\'erreur:', error?.name || 'Erreur inconnue');\nconsole.log('Message:', error?.message || 'Pas de message');\nconsole.log('Code HTTP:', error?.httpCode || 'N/A');\n\n// Analyse de l'erreur pour d√©terminer la strat√©gie\nlet errorType, canRetry, suggestedAction;\n\nif (error?.httpCode === 422) {\n  errorType = 'VALIDATION_API';\n  canRetry = true;\n  suggestedAction = 'V√©rifier la structure du payload';\n} else if (error?.httpCode === 401) {\n  errorType = 'AUTHENTICATION';\n  canRetry = false;\n  suggestedAction = 'V√©rifier la cl√© API';\n} else if (error?.httpCode === 429) {\n  errorType = 'RATE_LIMIT';\n  canRetry = true;\n  suggestedAction = 'R√©essayer apr√®s d√©lai';\n} else if (error?.httpCode >= 500) {\n  errorType = 'SERVER_ERROR';\n  canRetry = true;\n  suggestedAction = 'Probl√®me serveur Mistral, r√©essayer';\n} else {\n  errorType = 'UNKNOWN';\n  canRetry = false;\n  suggestedAction = 'Analyser l\\'erreur manuellement';\n}\n\nconst errorReport = {\n  error_type: errorType,\n  error_timestamp: new Date().toISOString(),\n  http_code: error?.httpCode,\n  error_message: error?.message,\n  error_details: error?.details || {},\n  can_retry: canRetry,\n  suggested_action: suggestedAction,\n  input_data_id: inputData.id,\n  payload_info: inputData.prompt_info\n};\n\nconsole.log('üìã Rapport d\\'erreur API:', JSON.stringify(errorReport, null, 2));\n\nreturn {\n  json: {\n    ...inputData,\n    api_error: errorReport,\n    status: 'ERREUR_API',\n    mistral_response: null,\n    classification: 'ERREUR',\n    processed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "api-error-handler",
      "name": "‚ùå Erreur API Mistral",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 500]
    },
    {
      "parameters": {
        "jsCode": "// ANALYSE S√âCURIS√âE DE LA R√âPONSE MISTRAL\nconst offre = $input.first().json;\nconst mistralResponse = $input.last().json;\n\nconsole.log(`üì• === ANALYSE R√âPONSE MISTRAL: ${offre.title} ===`);\n\n// Validation de la structure de r√©ponse\nif (!mistralResponse || typeof mistralResponse !== 'object') {\n  throw new Error('R√©ponse Mistral invalide: pas un objet JSON');\n}\n\nif (!mistralResponse.choices || !Array.isArray(mistralResponse.choices)) {\n  throw new Error('R√©ponse Mistral invalide: pas de choix disponibles');\n}\n\nif (mistralResponse.choices.length === 0) {\n  throw new Error('R√©ponse Mistral invalide: aucun choix retourn√©');\n}\n\nif (!mistralResponse.choices[0].message || !mistralResponse.choices[0].message.content) {\n  throw new Error('R√©ponse Mistral invalide: contenu du message manquant');\n}\n\nconst content = mistralResponse.choices[0].message.content.trim();\nconsole.log('üìù R√©ponse Mistral compl√®te:', content);\n\n// Classification avec validation robuste\nconst contentUpper = content.toUpperCase();\nlet classification, isValid, confidence, reasoning;\n\n// Patterns de classification plus robustes\nconst patterns = {\n  valide: [\n    /\\*\\*CLASSIFICATION\\*\\*:\\s*VALIDE/i,\n    /CLASSIFICATION:\\s*VALIDE/i,\n    /R√âPONSE:\\s*VALIDE/i,\n    /R√âSULTAT:\\s*VALIDE/i\n  ],\n  invalide: [\n    /\\*\\*CLASSIFICATION\\*\\*:\\s*INVALIDE/i,\n    /CLASSIFICATION:\\s*INVALIDE/i,\n    /R√âPONSE:\\s*INVALIDE/i,\n    /R√âSULTAT:\\s*INVALIDE/i\n  ]\n};\n\n// Extraction de la justification\nconst justificationMatch = content.match(/\\*\\*JUSTIFICATION\\*\\*:\\s*(.+?)(?:\\n|$)/i) ||\n                          content.match(/JUSTIFICATION:\\s*(.+?)(?:\\n|$)/i);\nreasoning = justificationMatch ? justificationMatch[1].trim() : 'Justification non trouv√©e';\n\n// Logique de classification\nconst hasValidePattern = patterns.valide.some(pattern => pattern.test(content));\nconst hasInvalidePattern = patterns.invalide.some(pattern => pattern.test(content));\n\nif (hasValidePattern && !hasInvalidePattern) {\n  classification = 'VALIDE';\n  isValid = true;\n  confidence = 0.95;\n} else if (hasInvalidePattern && !hasValidePattern) {\n  classification = 'INVALIDE';\n  isValid = false;\n  confidence = 0.95;\n} else if (contentUpper.includes('VALIDE') && !contentUpper.includes('INVALIDE')) {\n  classification = 'VALIDE';\n  isValid = true;\n  confidence = 0.8;\n} else if (contentUpper.includes('INVALIDE')) {\n  classification = 'INVALIDE';\n  isValid = false;\n  confidence = 0.8;\n} else {\n  classification = 'INCERTAIN';\n  isValid = false;\n  confidence = 0.3;\n  reasoning = 'Format de r√©ponse non conforme aux attentes';\n}\n\n// Validation avec r√©sultat attendu\nconst isCorrect = offre.attendu ? classification === offre.attendu : null;\n\nconsole.log(`üéØ Classification: ${classification}`);\nconsole.log(`üéØ Attendu: ${offre.attendu || 'N/A'}`);\nconsole.log(`‚úÖ Correct: ${isCorrect}`);\nconsole.log(`üîç Confiance: ${confidence}`);\n\nreturn {\n  json: {\n    ...offre,\n    mistral_response: content,\n    classification: classification,\n    is_valid: isValid,\n    confidence: confidence,\n    reasoning: reasoning,\n    model_used: mistralResponse.model || 'mistral-large-latest',\n    usage: mistralResponse.usage || {},\n    processed_at: new Date().toISOString(),\n    classification_correct: isCorrect,\n    status: 'SUCCESS',\n    response_analysis: {\n      hasValidePattern,\n      hasInvalidePattern,\n      content_length: content.length,\n      patterns_detected: {\n        valide: patterns.valide.filter(p => p.test(content)).length,\n        invalide: patterns.invalide.filter(p => p.test(content)).length\n      }\n    }\n  }\n};"
      },
      "id": "response-analyzer",
      "name": "üîç Analyse R√©ponse",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "jsCode": "// GESTIONNAIRE D'ERREUR GLOBAL POUR L'ANALYSE\nconst inputData = $input.first().json;\nconst error = $input.last().error;\n\nconsole.log(`‚ùå === ERREUR ANALYSE R√âPONSE ===`);\nconsole.log('Erreur:', error?.message || 'Erreur inconnue');\n\nconst errorReport = {\n  error_type: 'RESPONSE_ANALYSIS_ERROR',\n  error_timestamp: new Date().toISOString(),\n  error_message: error?.message,\n  input_data_id: inputData.id,\n  recovery_action: 'CLASSIFICATION_MANUELLE_REQUISE'\n};\n\nreturn {\n  json: {\n    ...inputData,\n    analysis_error: errorReport,\n    status: 'ERREUR_ANALYSE',\n    classification: 'ERREUR',\n    is_valid: false,\n    confidence: 0,\n    processed_at: new Date().toISOString()\n  }\n};"
      },
      "id": "analysis-error-handler",
      "name": "‚ùå Erreur Analyse",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 500]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "final-result",
              "name": "final_result",
              "value": "={{ $json }}",
              "type": "object"
            },
            {
              "id": "summary",
              "name": "summary",
              "value": "‚úÖ Traitement termin√© - ID: {{ $json.id }}, Status: {{ $json.status }}, Classification: {{ $json.classification }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "final-output",
      "name": "üìä R√©sultat Final",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [2000, 400]
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "üß™ G√©n√©rateur Test",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üß™ G√©n√©rateur Test": {
      "main": [
        [
          {
            "node": "‚úÖ Validation Donn√©es",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚úÖ Validation Donn√©es": {
      "main": [
        [
          {
            "node": "Donn√©es Valides ?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Donn√©es Valides ?": {
      "main": [
        [
          {
            "node": "üìù Pr√©paration Prompt",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Gestion Erreurs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùå Gestion Erreurs": {
      "main": [
        [
          {
            "node": "üìä R√©sultat Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìù Pr√©paration Prompt": {
      "main": [
        [
          {
            "node": "üåê Appel Mistral API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üåê Appel Mistral API": {
      "main": [
        [
          {
            "node": "üîç Analyse R√©ponse",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "‚ùå Erreur API Mistral",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùå Erreur API Mistral": {
      "main": [
        [
          {
            "node": "üìä R√©sultat Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Analyse R√©ponse": {
      "main": [
        [
          {
            "node": "üìä R√©sultat Final",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "error": [
        [
          {
            "node": "‚ùå Erreur Analyse",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚ùå Erreur Analyse": {
      "main": [
        [
          {
            "node": "üìä R√©sultat Final",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "enabled": false
    }
  },
  "versionId": "workflow-gestion-erreurs-v1",
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "id": "workflow-gestion-erreurs-complete",
  "tags": []
}